\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}

\SetKwProg{Fn}{Function}{ is}{}
\newcommand{\SetAlgoStyle}{
	\SetAlgoNoLine
	\SetAlgoNoEnd
	\DontPrintSemicolon
}

\newcommand{\fig}[2]{
	\begin{figure}[!htb]
		\center{\includegraphics[width=\textwidth,keepaspectratio]{res/#1}}
		\caption{\label{fig:caption} #2}
	\end{figure}
}

\title{SGSN word embedder optimization}
\author{Lazar Jelić}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}

This note provides new insight on time and memory optimization techniques for
skip-gram word embedding neural network with autoencoder architecture.

\end{abstract}

\pagebreak

\section{Introduction}

There are some ways to optimize computations and memory usage in the
original word2vec implementation. In this note we explore some of them. Source
code can be found at \url{https://github.com/jelic98/raf_nlp}.

\pagebreak

\section{Implementation}

We are implementing word embedder using C programming language.

\subsection{Network architecture}

As in the original word2vec implementation, we are using autoencoder
architecture which is capable of discovering structure within data in order
to develop a compressed representation of the input. If we pass word from
vocabulary to the input layer, then this representation will be word embedding.

\medbreak

Network consists of $3$ layers and $2$ weight matrices between them.

The first layer is the input layer which is onehot vector that uniquely represents a given word in the vocabulary.
We can denote it's vector as $\boldsymbol{x}$ and it's size as $I$.

\medbreak

The second layer is the hidden layer which input is the ouput from the input
layer.
We can denote it's vector as $\boldsymbol{h}$ and it's size as $J$.

\medbreak

The third layer is the output layer which input is the ouput from the hidden
layer.
We can denote it's vector as $\boldsymbol{y}$ and it's size as $K$.

\medbreak

Weights between input and hidden layer. We can denote this matrix as $\boldsymbol{V}$.

\medbreak

Weights between hidden and output layer. We can denote this matrix as $\boldsymbol{W}$.

\subsection{Vocabulary architecture}

Vocabulary is stored in memory as BST. Each node has the following

\begin{itemize}
	\item word string
	\item vocabulary index
	\item number of occurences in a corpus file
	\item size of context BoW
	\item context BoW as linked list
	\item auxiliary pointers
\end{itemize}

\subsection{Parsing pipeline}

Parsing pipeline overview is as follows

\begin{algorithm}[H]
	\SetAlgoStyle
	$vocab \gets$ BinarySearchTree()\;
		\For{$word$ \textbf{in} $vocab$}{
			clean($word$)\;
			\If{$word \notin stopWords$}{
				$center \gets$ createNode($word$)\;
				insertBST($vocab$, $center$)\;
				$window[WINDOW\_MAX] \gets center$\;
				\For{$c \gets 0$ \textbf{to} $WINDOW\_MAX - 1$}{
					\If{$window[c] \neq center$}{
						insertList($center.context$, $window[c]$)\;
						insertList($window[c].context$, $center$)\;
					}
					$window[c] = window[c+1]$\;
				}
			}
		}
	\caption{Parsing pipeline}
\end{algorithm}

Firstly, we are reading a corpus file, i.e. unfiltered file with sentences.
While we are doing that, we are cleaning the corpus by removing special
characters, numbers and stop words, and converting every word to it's
lowercase representation. As we said, unique words are stored in BST
vocabuary so we are going to perferm recursive, but preferably iterative,
insert operation. We are using window sliding technique to create context BoW 
for each center word by appending pointers to a linked list contained in the
corresponding BST node.

\medbreak

After reading the corpus file and populating BST with unique words, we need to
dynamically allocate required collection of structures in memory. Those
collections include

\begin{itemize}
	\item onehot word representation array
	\item input, hidden and output network layer
	\item input-hidden and hidden-output weight matrices
	\item prediction errors array
	\item training order array
	\item helper sampling matrix for NS phase
\end{itemize}

\medbreak

Then, we are populating hash map which is going to be used for asscociating
word and it's unique vocabulary index generated by preorder BST traversal.

\medbreak

After that, we need to calculated word frequency that will be needed
int the NS stage for random word sampling using Monte Carlo method inverse
proportional to it's frequency in order to lower the chances of sampling
high-frquency words.

\subsection{Weights initialization}

For now, we are using just a randomly sampled real numbers from uniform distrubution in the interval
$[0, 1]$. Prediction accuracy could increase if we'd sample initial weight values from Gaussian
distrubution.

\subsection{Training pipeline}

Training phase consists of multiple epochs and in each one of them passing
every vocabulary word to input layer. We are not calculating loss function
because it's value is not required. Notice that we are done reading the file
and training phase is using only generated vocabulary from previous phase.
This results in training the network for a particular word only once and
independent of it's frequency.

\medbreak

To illustrate the idea mentioned above, let's compare original word2vec and our implementation.

\textbf{Original word2vec implementation.}
Initialize sliding window at the beginning of the file. For each center word $\boldsymbol{x}$, create context BoW $\boldsymbol{C}$. For each context word $\boldsymbol{c_i} \in \boldsymbol{C}$, run training for pair $(\boldsymbol{x}, \boldsymbol{c_i})$ and calculate error vector $\boldsymbol{e}$ at the output layer. This way we run $|\boldsymbol{C}|$ training passes for each center word.

\textbf{Our implementation.}
Given a vocabulary $\mathcal{V}$, for each $\boldsymbol{x} \in \mathcal{V}$ run training for pair $(\boldsymbol{x}, \boldsymbol{C})$, where $\boldsymbol{C}$ is a context BoW of center word $\boldsymbol{x}$. This way we run only one training pass for each center word.

Training pipeline overview is as follows

\begin{algorithm}[H]
	\SetAlgoStyle
	\For{$epoch \gets 0$ \textbf{to} $EPOCH\_MAX$}{
		$vocab \gets$ shuffle(vocab)\;
		\For{$word$ \textbf{in} $vocab$}{
			propagateForward()\;
			normalizeOutput()\;
			sampleNegatives()\;
			calculateError()\;
			propagateBackward()\;
		}
		sarializeWeights()\;
	}
	\caption{Training pipeline}
\end{algorithm}

\subsection{Testing pipeline}

Testing pipeline overview is as follows

\begin{algorithm}[H]
	\SetAlgoStyle
	$success \gets total \gets 0$\;
	\For{$word$ \textbf{in} $test$}{
		clean($word$)\;
		\If{$word \notin stopWords$}{
			propagateForward()\;
			normalizeOutput()\;
			$prob \gets max(output)$
			$pred \gets$ indexOf($prob$)\;
			\If{$word = pred$}{
				$success \gets success + 1$\;
			}
			$total \gets total + 1$\;
		}
	}
	$acc \gets success / total$\;
	\caption{Testing pipeline}
\end{algorithm}

\subsection{Process of learning}

Forawrd propagation of input is done as follows

\begin{align}
	&h_j = \sum_{i=1}^I x_i \cdot V_{ij} \\
	&y_k = \sum_{j=1}^J h_j \cdot W_{jk} \\
	&E = \frac{1}{2} \cdot \sum_{k=1}^K (y_k - t_k)^2
\end{align}

Backward error propagation is done using relationships defined by

\begin{align}
	&W_{jk}^\prime = W_{jk} - \alpha \cdot \frac{\partial E}{\partial W_{jk}}
	\cdot y_k = W_{jk} - \alpha \cdot (y_k - t_k) \cdot h_j \cdot y_k \\
	&V_{ij}^\prime = V_{ij} - \alpha \cdot \frac{\partial E}{\partial V_{ij}}
	\cdot h_j = V_{ij} - \alpha \cdot (y_k - t_k) \cdot W_{jk} \cdot x_i \cdot
	h_j
\end{align}

where $\alpha$ is a learning rate hyperparameter which value is decreasing as
training progresses using simulated annealing technique.

Partial derrivatives we've used are as follows

\begin{align}
	&\frac{\partial h_j}{\partial V_{ji}} = \frac{\partial}{\partial V_{ij}}
	\Big(x_i \cdot V_{ij}\Big) = x_i \\
	&\frac{\partial y_k}{\partial h_j} = \frac{\partial}{\partial h_j}
	\Big(h_j \cdot W_{jk}\Big) = W_{jk} \\
	&\frac{\partial y_k}{\partial W_{jk}} = \frac{\partial}{\partial W_{jk}}
	\Big(h_j \cdot W_{jk}\Big) = h_j \\
	&\frac{\partial E}{\partial y_k} = \frac{\partial}{\partial y_k}
	\Big(\frac{1}{2} \cdot (y_k - t_k)^2\Big) = y_k - t_k \\
	&\frac{\partial E}{\partial W_{jk}} = \frac{\partial E}{\partial y_k} \cdot
	\frac{\partial y_k}{\partial W_{jk}} = (y_k - t_k) \cdot h_j \\
	&\frac{\partial E}{\partial V_{ij}} = \frac{\partial E}{\partial y_k} \cdot
	\frac{\partial y_k}{\partial V_{ij}} = \frac{\partial E}{\partial y_k} \cdot
	\frac{\partial y_k}{\partial h_j} \cdot \frac{\partial h_j}{\partial V_{ij}}
	= (y_k - t_k) \cdot W_{jk} \cdot x_i
\end{align}

\subsection{Hyperparameters}

We are using hyperparameter defined below to tweak our network in order to get the best accuracy and performance.

\begin{itemize}
	\item $EPOCH\_MAX$ - Total epochs in per training
	\item $HIDDEN\_MAX$ - Number of neurons in hidden layer
	\item $WINDOW\_MAX$ - Size of sliding window, i.e. size of context BoW
	\item $WEIGHT\_MAX$ - Upper bound for initial weight value sampling
	\item $ALPHA\_MAX$ - Initial learning rate value
	\item $ALPHA\_MIN$ - Final learning rate value
	\item $SAMPLES\_MAX$ - Number of negative samples to pick
	\item $FREQ\_FACTOR$ - Multiplies word's frequency while sampling
	\item $SAMPLE\_EMERGENCY$ - Upper bound for unsuccessful samplings
\end{itemize}

\medbreak

Value for $HIDDEN\_MAX$ hyperparameter would preferably be selected using a
special algorithm proposed by Branislav Milojković.

\subsection{Negative sampling}

Implementation in progress.

\pagebreak

\section{Vector representations of sentences}

Word embeddings on their own are useful for analyzing relationships between
words, but encoding sentences can give us better semantic understanding of
larger chunks of text. Sentence encoding is done as follows

\begin{algorithm}[H]
	\SetAlgoStyle
	\Fn{encode(sentence)}{
		\For{$word$ \textbf{in} $sentence$}{
			clean($word$)\;
			\If{$word \notin stopWords$}{
				$i \gets$ indexOf($word$)\;
				\For{$j \gets 0$ \textbf{to} $HIDDEN\_MAX$}{
					$vec[j] \gets vec[j] + V[i][j]$\;
				}
			}
		}
		\Return{$vec$}\;
	}
	\caption{Sentence encoding}
\end{algorithm}

\pagebreak

\section{Results and discussion}

Show charts and tables showing test accuracy and preformance caused by tweaking
hyperparameters.

\fig{chart}{Caption example}

\end{document}
